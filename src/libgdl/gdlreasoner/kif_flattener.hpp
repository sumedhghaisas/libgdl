/**
 * @file kif_flattener.hpp
 * @author Sumedh Ghaisas
 *
 * Declaration of KIFFlattener class.
 */
#ifndef _LIBGDL_GDLREASONER_KIF_FLATTENER_HPP_INCLUDED
#define _LIBGDL_GDLREASONER_KIF_FLATTENER_HPP_INCLUDED

#include <string>
#include <set>

#include <libgdl/core.hpp>
#include <libgdl/gdlparser/kif.hpp>
#include <libgdl/gdlreasoner/knowledgebase.hpp>

namespace libgdl
{
namespace gdlreasoner
{
/**
 * This class represents KIF flattener. It converts all the clause to ground
 * form, or in other words removes all the variables. KIFFlattener takes KIF
 * object as its input. Dependency graph generated by KIF is used extensively
 * in flattening. Using dependency graph, bottom up dependency parsing is done
 * which completes in only one iteration.
 *
 * @note This flattener will remove all the occurrences data relations
 * (relations which are independent of true and does e.g. successor, index etc.)
 * from facts and clauses as they are no longer required when description
 * is flattened.
 *
 * Sample use -
 * @code
 * KIF kif;
 * kif.AddFile("3puzzle.kif");
 * kif.Parse();
 *
 * KIFFlattener kf;
 * kf.Flatten(kf);
 *
 * std::list<Fact> facts = kf.GetFlattenedFacts();
 * std::list<Clause> clauses = kf.GetFlattenedClauses();
 *
 * kf.PrintToFile("3puzzle_flattened.kif");
 * @endcode
 *
 * @see KIF, KnowledgeBase
 */
class KIFFlattener
{
  typedef core::Fact Fact;
  typedef core::Clause Clause;
  typedef core::Argument Argument;
  typedef core::DGraph DGraph;
  typedef core::DGraphNode DGraphNode;
  typedef core::SymbolTable SymbolTable;

 public:
  //! empty constructor
  KIFFlattener() {}

  //! flattened the knowledge in given KIF object and stores the flattened knowledge
  void Flatten(gdlparser::KIF& kif);

  //! print the current flattened knowledge
  bool PrintToFile(const std::string& filename);

  //! get all facts
  const std::list<Fact>& GetFlattenedFacts() const { return flattened_facts; }
  //! get all clauses
  const std::list<Clause>& GetFlattenedClauses() const { return flattened_clauses; }

 private:
  //! performs simple DFS and returns all the relations traversed
  void DFSMarking(const DGraphNode* node, std::set<size_t>& marked);

  //! flattenes the relation represented by given dependency graph node
  //! all the flattened clauses and facts of given relation are added to
  //! appropriate lists.
  void FlattenRelation(const DGraphNode* n,
                       const KnowledgeBase& all_kb,
                       const std::set<size_t>& state_independent,
                       KnowledgeBase& m_kb,
                       std::list<Clause>& f_clauses,
                       std::list<Fact>& f_facts);

  //! pre-processes clause before flattening
  Clause* ProcessClause(Clause& c, const std::set<size_t>& state_independent);
  //! pre-processes argument before flattening
  Argument* ProcessPremiss(Argument* arg,
                           const std::set<size_t>& state_independent);

  //! returns new argument, copy of the given argument but only shallow copy for variables
  Argument* SpecialArgCopy(Argument* arg, std::set<Argument*>& vars);

  //! deletes arguments created by SpecialArgCopy
  //! does not delete variables
  void SpecialArgDelete(Argument* arg);
  //! deletes clauses created with SpecialArgCopy
  //! does not delete variables
  void SpecialClauseDelete(Clause* c);

  //! removes all the data relations from the clause
  //! also removes distinct, role, input, base from the premisses as they are no longer required
  //! after flattening
  Clause* RemoveDataFromClause(Clause* c,
                               const std::set<size_t>& state_independent);
  //! removes all the data relations from the argument
  //! used when 'or' is encountered in the premiss
  Argument* RemoveDataFromArgument(Argument* arg,
                                   const std::set<size_t>& state_independent);

  //! stores flattened facts
  std::list<Fact> flattened_facts;
  //! stores flattened clauses
  std::list<Clause> flattened_clauses;

  SymbolTable* symbol_table;
}; // class KIFFlattener

}; // namespace gdlreasoner
}; // namespace libgdl

#endif //_LIBGDL_GDLREASONER_KIF_FLATTENER_HPP_INCLUDED
