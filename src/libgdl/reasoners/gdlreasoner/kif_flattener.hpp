/**
 * @file kif_flattener.hpp
 * @author Sumedh Ghaisas
 *
 * Declaration of KIFFlattener class.
 */
#ifndef _LIBGDL_GDLREASONER_KIF_FLATTENER_HPP_INCLUDED
#define _LIBGDL_GDLREASONER_KIF_FLATTENER_HPP_INCLUDED

#include <string>
#include <set>

#include <libgdl/core.hpp>
#include <libgdl/core/data_types/variable_map.hpp>
#include <libgdl/gdlparser/kif.hpp>

#include "knowledgebase.hpp"

namespace libgdl
{
namespace gdlreasoner
{
/**
 * This class represents KIF flattener. It converts all the clause to ground
 * form, or in other words removes all the variables. KIFFlattener takes KIF
 * object as its input. Dependency graph generated by KIF is used extensively
 * in flattening. Using dependency graph, bottom up dependency parsing is done
 * which completes in only one iteration.
 *
 * @note This flattener will remove all the occurrences data relations
 * (relations which are independent of true and does e.g. successor, index etc.)
 * from facts and clauses as they are no longer required when description
 * is flattened.
 *
 * Sample use -
 * @code
 * KIF kif;
 * kif.AddFile("3puzzle.kif");
 * kif.Parse();
 *
 * KIFFlattener kf;
 * kf.Flatten(kf);
 *
 * std::list<Fact> facts = kf.GetFlattenedFacts();
 * std::list<Clause> clauses = kf.GetFlattenedClauses();
 *
 * kf.PrintToFile("3puzzle_flattened.kif");
 * @endcode
 *
 * @see KIF, KnowledgeBase
 */
class KIFFlattener
{
  //! For simplicity
  typedef core::Fact Fact;
  typedef core::Clause Clause;
  typedef core::Argument Argument;
  typedef core::DGraph DGraph;
  typedef core::DGraphNode DGraphNode;
  typedef core::SymbolTable SymbolTable;

 public:
  //! Empty constructor
  //!
  //! \param log Logging stream
  //!
  //!
  explicit KIFFlattener(Log log = GLOBAL_LOG)
    : combination_optimization_index(0), log(log) {}

  //! Flattens the knowledge in given KIF object
  //!
  //! \param kif KIF object to flatten
  //! \return void
  //!
  //!
  template<typename Collector>
  void Flatten(gdlparser::KIF& kif, Collector& collector, bool useCache = true);

 private:
  bool IsSelfRecursive(const Clause& c);

  std::set<size_t> GetStateIndependentRelations(const KnowledgeBase& all_kb,
                                                KnowledgeBase& m_kb,
                                                const std::map<size_t, DGraphNode*>& dgraph);

  void AddStateIndependentRelationToCache(const std::set<size_t>& state_independent,
                                          const std::map<size_t, DGraphNode*>& dgraph,
                                          KnowledgeBase& m_kb);

  template<typename Collector>
  void OptimizeClausesForPropnet(std::list<Clause>& opt_clauses,
                                 Argument* opt_args,
                                 SymbolTable symbol_table,
                                 size_t& combination_optimization_index,
                                 Collector& collector);

  void InitializePropnetOptimizer(const Clause& c,
                                  Clause* temp,
                                  std::list<Clause>& opt_clauses,
                                  Argument* opt_args);

  template<typename Collector>
  void FlattenClause(const Clause& clause,
                     const std::set<size_t>& state_independent,
                     const SymbolTable& symbol_table,
                     std::list<Argument*>& f_heads,
                     Collector& collector,
                     std::list<const Clause*>& rec_clauses,
                     KnowledgeBase& m_kb,
                     size_t& combination_optimization_index);

  template<typename Collector>
  void FlattenRecursiveClause(const Clause& clause,
                              const std::set<size_t>& state_independent,
                              core::SymbolTable& symbol_table,
                              std::list<Argument*>& f_heads,
                              Collector& collector,
                              KnowledgeBase& m_kb);

  //! Performs simple DFS and returns all the relations traversed
  //!
  //! \param node Node to start the DFS from
  //! \param marked Set of all the relations encountered
  //! \return void
  //!
  //!
  void DFSMarking(const DGraphNode* node, std::set<size_t>& marked);

  //! Flattens the relation represented by given dependency graph node
  //! All the flattened clauses and facts of given relation are added to
  //! appropriate lists.
  //!
  //! \param n DGraphNode to flatten
  //! \param all_kb KnowledgeBase which stores all the given knowledge
  //! \param state_independent Set of state independent relations
  //! \param m_kb The current flattened knowledge
  //! \param f_clauses List flattened clauses
  //! \param f_facts List of flattened facts
  //! \return void
  //!
  //!
  template<typename Collector>
  void FlattenRelation(const DGraphNode* n,
                       const KnowledgeBase& all_kb,
                       const std::set<size_t>& state_independent,
                       KnowledgeBase& m_kb,
                       Collector& collector,
                       bool useCache);

  //! Preprocesses clause before flattening
  //! Returns the clause with special substitution
  //!
  //! \param c Cluse to preprocess
  //! \param state_independent Set of state independent relations
  //! \return Clause*
  //!
  //!
  Clause* ProcessClause(const Clause& c,
                        const std::set<size_t>& state_independent);
  //! Preprocesses argument before flattening
  //!
  //! \param arg Argument to preprocess
  //! \param state_independent Set of state independent relations
  //! \return Clause*
  //!
  //!
  Argument* ProcessPremiss(Argument* arg,
                           const std::set<size_t>& state_independent);

  //! Returns new argument by coping of the given argument
  //! This functions performs deep copy except for the instances of GDL
  //! variables, for which shallow copy is performed.
  //!
  //! \param arg Argument to copy
  //! \param vars Set of GDL variables
  //! \return Argument*
  //!
  //!
  Argument* SpecialArgCopy(Argument* arg, std::set<Argument*>& vars);

  //! Deletes arguments created by SpecialArgCopy
  //! Instances GDL variable are not deleted
  //!
  //! \param arg Argument to delete
  //! \return void
  //!
  //!
  void SpecialArgDelete(Argument* arg);

  //! Deletes clauses created with SpecialArgCopy
  //!
  //! \param c Clause to delete
  //! \return void
  //!
  //!
  void SpecialClauseDelete(Clause* c);

  //! Removes all the data relations from the clause as they no longer required
  //! after flattening. Also removes distinct, role, input, base from the
  //! premisses.
  //!
  //! \param c Clause to process
  //! \param state_independent Set of state independent relations
  //! \return Clause*
  //!
  //!
  Clause* RemoveDataFromClause(Clause* c,
                               const std::set<size_t>& state_independent);

  //! Removes all the data relations from the argument
  //!
  //! \param arg Argument to process
  //! \param state_independent Set of state independent relations
  //! \return Argument*
  //!
  //!
  Argument* RemoveDataFromArgument(Argument* arg,
                                   const std::set<size_t>& state_independent);

  Argument* SpecialArgCopy2(Argument* arg,
                            core::VariableMap& v_map);

  size_t combination_optimization_index;

  //! Logging stream
  Log log;
}; // class KIFFlattener

}; // namespace gdlreasoner
}; // namespace libgdl

#include "kif_flattener_impl.hpp"

#endif //_LIBGDL_GDLREASONER_KIF_FLATTENER_HPP_INCLUDED
