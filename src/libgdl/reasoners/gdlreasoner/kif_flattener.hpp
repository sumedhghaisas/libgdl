/**
 * @file kif_flattener.hpp
 * @author Sumedh Ghaisas
 *
 * Declaration of KIFFlattener class.
 */
#ifndef _LIBGDL_GDLREASONER_KIF_FLATTENER_HPP_INCLUDED
#define _LIBGDL_GDLREASONER_KIF_FLATTENER_HPP_INCLUDED

#include <string>
#include <set>

#include <libgdl/core.hpp>
#include <libgdl/gdlparser/kif.hpp>

#include "knowledgebase.hpp"

namespace libgdl
{
namespace gdlreasoner
{
/**
 * This class represents KIF flattener. It converts all the clause to ground
 * form, or in other words removes all the variables. KIFFlattener takes KIF
 * object as its input. Dependency graph generated by KIF is used extensively
 * in flattening. Using dependency graph, bottom up dependency parsing is done
 * which completes in only one iteration.
 *
 * @note This flattener will remove all the occurrences data relations
 * (relations which are independent of true and does e.g. successor, index etc.)
 * from facts and clauses as they are no longer required when description
 * is flattened.
 *
 * Sample use -
 * @code
 * KIF kif;
 * kif.AddFile("3puzzle.kif");
 * kif.Parse();
 *
 * KIFFlattener kf;
 * kf.Flatten(kf);
 *
 * std::list<Fact> facts = kf.GetFlattenedFacts();
 * std::list<Clause> clauses = kf.GetFlattenedClauses();
 *
 * kf.PrintToFile("3puzzle_flattened.kif");
 * @endcode
 *
 * @see KIF, KnowledgeBase
 */
class KIFFlattener
{
  //! For simplicity
  typedef core::Fact Fact;
  typedef core::Clause Clause;
  typedef core::Argument Argument;
  typedef core::DGraph DGraph;
  typedef core::DGraphNode DGraphNode;
  typedef core::SymbolTable SymbolTable;

 public:
  //! Empty constructor
  //!
  //! \param log Logging stream
  //!
  //!
  explicit KIFFlattener(Log log = GLOBAL_LOG)
    : log(log) {}

  //! Flattens the knowledge in given KIF object
  //!
  //! \param kif KIF object to flatten
  //! \return void
  //!
  //!
  void Flatten(gdlparser::KIF& kif, bool useCache = true);

  //! Flattens the knowledge in given KIF object
  //!
  //! \param kif KIF object to flatten
  //! \return void
  //!
  //!
  template<typename Collector>
  void Flatten(gdlparser::KIF& kif, Collector& collector, bool useCache = true);

  //! Print the current flattened knowledge to file
  //! Returns the success state
  //!
  //! \param filename Filename
  //! \return bool
  //!
  //!
  bool PrintToFile(const std::string& filename);

  //! Clears the knowledge inside this flattener object
  //!
  //! \return void
  //!
  //!
  void Clear()
  {
    flattened_clauses.clear();
    flattened_clauses.clear();

    symbol_table = NULL;
  }

  //! Access all the flattened facts(Read)
  const std::list<Fact>& Facts() const
  {
    return flattened_facts;
  }
  //! Access all te flattened facts(Write)
  std::list<Fact>& Facts()
  {
    return flattened_facts;
  }
  //! Access all the flattened clauses(Read)
  const std::list<Clause>& Clauses() const
  {
    return flattened_clauses;
  }
  //! Access all the flattened clauses(Write)
  std::list<Clause>& Clauses()
  {
    return flattened_clauses;
  }

  //! Get symbol table associated with this flattener
  SymbolTable GetSymbolTable() const
  {
    return symbol_table;
  }

 private:
  std::set<size_t> GetStateIndependentRelations(const KnowledgeBase& all_kb,
                                                KnowledgeBase& m_kb,
                                                const std::map<size_t, DGraphNode*>& dgraph);

  void AddStateIndependentRelationToCache(const std::set<size_t>& state_independent,
                                          const std::map<size_t, DGraphNode*>& dgraph,
                                          KnowledgeBase& m_kb);

  void FlattenClause(const Clause& clause,
                     const std::set<size_t>& state_independent,
                     std::list<Argument*>& f_heads,
                     std::list<Clause>& f_clauses,
                     std::list<Fact>& f_facts,
                     std::list<const Clause*>& rec_clauses,
                     KnowledgeBase& m_kb);

  void FlattenRecursiveClause(const Clause& clause,
                              const std::set<size_t>& state_independent,
                              std::list<Argument*>& f_heads,
                              std::list<Clause>& f_clauses,
                              std::list<Fact>& f_facts,
                              KnowledgeBase& m_kb);

  //! Performs simple DFS and returns all the relations traversed
  //!
  //! \param node Node to start the DFS from
  //! \param marked Set of all the relations encountered
  //! \return void
  //!
  //!
  void DFSMarking(const DGraphNode* node, std::set<size_t>& marked);

  //! Flattens the relation represented by given dependency graph node
  //! All the flattened clauses and facts of given relation are added to
  //! appropriate lists.
  //!
  //! \param n DGraphNode to flatten
  //! \param all_kb KnowledgeBase which stores all the given knowledge
  //! \param state_independent Set of state independent relations
  //! \param m_kb The current flattened knowledge
  //! \param f_clauses List flattened clauses
  //! \param f_facts List of flattened facts
  //! \return void
  //!
  //!
  void FlattenRelation(const DGraphNode* n,
                       const KnowledgeBase& all_kb,
                       const std::set<size_t>& state_independent,
                       KnowledgeBase& m_kb,
                       std::list<Clause>& f_clauses,
                       std::list<Fact>& f_facts,
                       bool useCache);

  //! Preprocesses clause before flattening
  //! Returns the clause with special substitution
  //!
  //! \param c Cluse to preprocess
  //! \param state_independent Set of state independent relations
  //! \return Clause*
  //!
  //!
  Clause* ProcessClause(const Clause& c,
                        const std::set<size_t>& state_independent);
  //! Preprocesses argument before flattening
  //!
  //! \param arg Argument to preprocess
  //! \param state_independent Set of state independent relations
  //! \return Clause*
  //!
  //!
  Argument* ProcessPremiss(Argument* arg,
                           const std::set<size_t>& state_independent);

  //! Returns new argument by coping of the given argument
  //! This functions performs deep copy except for the instances of GDL
  //! variables, for which shallow copy is performed.
  //!
  //! \param arg Argument to copy
  //! \param vars Set of GDL variables
  //! \return Argument*
  //!
  //!
  Argument* SpecialArgCopy(Argument* arg, std::set<Argument*>& vars);

  //! Deletes arguments created by SpecialArgCopy
  //! Instances GDL variable are not deleted
  //!
  //! \param arg Argument to delete
  //! \return void
  //!
  //!
  void SpecialArgDelete(Argument* arg);

  //! Deletes clauses created with SpecialArgCopy
  //!
  //! \param c Clause to delete
  //! \return void
  //!
  //!
  void SpecialClauseDelete(Clause* c);

  //! Removes all the data relations from the clause as they no longer required
  //! after flattening. Also removes distinct, role, input, base from the
  //! premisses.
  //!
  //! \param c Clause to process
  //! \param state_independent Set of state independent relations
  //! \return Clause*
  //!
  //!
  Clause* RemoveDataFromClause(Clause* c,
                               const std::set<size_t>& state_independent);

  //! Removes all the data relations from the argument
  //!
  //! \param arg Argument to process
  //! \param state_independent Set of state independent relations
  //! \return Argument*
  //!
  //!
  Argument* RemoveDataFromArgument(Argument* arg,
                                   const std::set<size_t>& state_independent);

  Argument* SpecialArgCopy2(Argument* arg,
                            core::VariableMap& v_map);

  //! Stores flattened facts
  std::list<Fact> flattened_facts;
  //! Stores flattened clauses
  std::list<Clause> flattened_clauses;
  //! Symbol table
  SymbolTable symbol_table;
  //! Logging stream
  Log log;
}; // class KIFFlattener

}; // namespace gdlreasoner
}; // namespace libgdl

#endif //_LIBGDL_GDLREASONER_KIF_FLATTENER_HPP_INCLUDED
